# 每日计划
以下耗时统一使用番茄钟为单位进行计时，一个番茄钟半小时
目前进入到面向面经学习阶段，即看面经的题目以及高强度刷题，每个部分都要准备，可以把每天看过的东西记录下来，目前准备记在石墨文档上
## 算法 2个番茄钟
- [x] 剑指 Offer 56 - I. 数组中数字出现的次数
- [x] 剑指 Offer 56 - II. 数组中数字出现的次数 II

## 操作系统 
linux 文件管理
## 计算机网络 
哈工大 第8周，第9周内容
## 编程语言 8个番茄钟
- [x] C/C++内存有哪几种类型, https://zhuanlan.zhihu.com/p/388189197
- [x] 静态链接
用 gcc 来进行编译程序的时候有四个步骤
预处理，编译，汇编，链接，其中我们需要重点理解链接的过程。
原始的链接概念早在高级语言之前就已经存在，程序需要读取变量和函数的地址，早期的纸带编程要做到跳转非常麻烦，我们这里需要了解几个概念
- 汇编语言发明后有了 Symbol 的概念，他用来表示一个地址，可以是一段函数的起始地址，也可以是一个变量的起始地址。
- 模块：人们将代码按照功能和性质划分，分成不同的模块，在C语言中，最小的单位是变量和函数，若干个变量和函数组成一个模块，存在 .c 的源代码文件中。

一个程序被划分为多个模块后，需要解决的就是模块之间如何组合的问题，归根到底就是**模块之间如何通信**的问题。
对于静态语言 C/C++ 模块之间有两种通信方式
- 模块间的函数调用
- 模块间的变量访问
上述两种方式归结为一点就是：**模块间符号的引用**，人们按照需要将每个源代码模块独立地编译，然后按照需要将他们组装起来，这个组装的过程就是**链接**。
链接过程主要包括：
- 地址和空间分配 Address and Storage
- 符号决议 Symbol Resolution
- 重定位 Relocation 给程序中每个这样的绝对地址引用的位置打补丁，使他指向正确的位置（其他模块的函数和变量）
**运行库是支持程序运行的基本函数集合**。
ELF 格式的文件归为4类，可以用 `file` 命令来判断是哪类
ELF 格式的结构：
- .text 保存执行语句编译成的机器代码
- .data 已初始化的全局变量和局部静态变量
- .bss 未初始化的全局变量和局部静态变量，**这块区域只是占位预留位置，并没有内容，在文件中也不占据空间**
- .rodata 只读数据，一般是程序中的只读变量（const 修饰的），和字符串常量（有些编译器也会放在.data中）

c语言静态库 /usr/lib/libc.a 是 glibc 的一部分。可以使用 `ar -t libc.a` 查看里面有哪些文件
libc.a 中每个目标文件只有一个函数，这样可以保证链接的时候只需要链接对应的目标文件，节省空间
VMA：linux 中将进程虚拟空间中的一个段叫做虚拟内存区域
一个进程基本可以分为如下几个 VMA 区域：
- 代码VMA
- 数据VMA
- 堆VMA
- 栈VMA
- 保留区 保留区不是一个单一的内存区域，而是对内存中受到保护而禁止访问的内存区域的总称
- 动态链接库映射区 这个区域用来映射装载的动态链接库

- [x] 动态链接
为什么要有动态链接：
- 静态链接浪费内存和磁盘空间
- 任意一个模块改动，程序就要重新链接，分布给用户
动态链接好处：
- 节省内存
- 减少物理页面的换入换出
- 增加CPU缓存

- [x] C++中有哪四个和类型转换相关的关键字，这些关键字有什么特点，应该在什么场合下使用？
	- dynamic_cast:可以用来转换指针，失败返回空指针，也可以用来转换引用，失败抛出异常 bad_cast
	- static_cast: 通过上面的介绍，我们可以很直观地看到static_cast相比C风格的强制类型转换要安全很多，有很大程度上的类型安全检查。本节我们所有的例子都可以使用C风格的强制类型转换去做，但是转出来的结果有可能会错到天际去，并且编译器不会给你任何报错信息。。。同时我们也要认识到static_cast也是有明显缺点的，那就是无法消除const和volatile属性、无法直接对两个不同类型的指针或引用进行转换和下行转换无类型安全检查等，不过没关系，其它三个强制类型转换的关键字刚好能弥补static_cast的这些缺点。
	- const_cast: 作用是去除掉const或volitale属性，前面介绍static_cast的时候我们知道static_cast是不具备这种功能的。使用格式如下：const_cast<type_id>(expression);
		注意事项：const_cast**不是用于去除变量的常量性，而是去除指向常量对象的指针或引用的常量性，其去除常量性的对象必须为指针或引用，并且const_cast不支持不同类型指针或引用之间的转换，比如说float*转换成int*是不允许的，直白一点说就是type_id和expression要基本类型保持一致，相差的话只能差const或volatile属性。** 如果该变量本身不是 const， 那么是可以通过其改变的
	- reinterpret_cast意为“重新解释”，它是C++中最接近于C风格强制类型转换的一个关键字。它让程序员能够将一种对象类型转换为另一种，不管它们是否相关。使用格式如下：`reinterpret_cast<type_id>(expression);`
		type-id和expression中必须有一个是指针或引用类型（可以两个都是指针或引用，指针引用在一定场景下可以混用，但是建议不要这样做，编译器也会给出相应的警告）。
reinterpret_cast的第一种用途是改变指针或引用的类型
reinterpret_cast的第二种用途是将指针或引用转换为一个整型，这个整型必须与当前系统指针占的字节数一致
reinterpret_cast的第三种用途是将一个整型转换为指针或引用类型
可以先使用reinterpret_cast把一个指针转换成一个整数，再把该整数转换成原类型的指针，还可以得到原先的指针值（由于这个过程中type-id和expression始终有一个参数是整形，所以另一个必须是指针或引用，并且整型所占字节数必须与当前系统环境下指针占的字节数一致）
使用reinterpret_cast强制转换过程仅仅只是比特位的拷贝，和C风格极其相似（但是reinterpret_cast不是全能转换，详见第1点），实际上reinterpret_cast的出现就是为了让编译器强制接受static_cast不允许的类型转换，因此使用的时候要谨而慎之
reinterpret_cast同样也不能转换掉expression的const或volitale属性。



- [x] RTTI
https://blog.csdn.net/weixin_43798887/article/details/118541570
https://nirvana1997.github.io/RTTI%E7%9A%84%E5%8E%9F%E7%90%86/

- RAII
- 异常处理，异常安全性
- 智能指针
- shared_ptr bind function

## 项目 
kafka 如何做到高性能
mysql如何消除幻读
mysql的并发问题

- [] 复习linux的信号，IO模型
- [] 加上异步日志
- [] 改为智能指针实现
- [] 想面试题的答案

C++
- [] 智能指针，RAII
- [] new delete
- [] 内存模型——侯捷视频+hit视频
- [] c++ c 多线程相关编程，生产者消费者例子
- [] c++ 新特性
- [] std源码